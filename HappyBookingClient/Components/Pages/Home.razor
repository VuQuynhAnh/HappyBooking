@page "/"
@using Blazored.LocalStorage
@using HappyBookingClient.Components.Layout
@using HappyBookingClient.Components.Pages.Chat
@using HappyBookingClient.Service.IService
@using HappyBookingShare.Common
@using HappyBookingShare.Model
@using HappyBookingShare.Request.Chat
@using HappyBookingShare.Response.Dtos
@using Microsoft.AspNetCore.SignalR.Client
@using System.Text.Json
@using System.Globalization
@inject ILanguageService _languageService
@inject IChatService _chatService
@inject IDialogService _dialogService
@inject ILocalStorageService _localStorage
@inject IJSRuntime _jSRuntime
@inject NavigationManager _navigation
@inject IConfiguration _configuration
<style>
    .textLeftButton {
        justify-content: left;
    }

    .searchBoxStyle .mud-input > input.mud-input-root-outlined {
        padding: 13.5px 14px;
    }

    .chatSelected {
        background: #d3e3fd;
    }
</style>

<MudGrid Justify="Justify.Center">
    <MudItem md="4" sm="12" xs="12" Class="mt-2">
        <MudButton Size="Size.Large"
                   Class="mb-2"
                   Variant="Variant.Outlined"
                   EndIcon="@Icons.Material.Filled.ChatBubbleOutline"
                   Color="Color.Default"
                   FullWidth
                   OnClick="OpenAddNewChatDialog">
            @_languageService["NewChat"]
        </MudButton>

        <MudPaper Class="pa-4">
            <MudButton FullWidth Class="textLeftButton" Color="Color.Success">@_languageService["DirectMessages"]</MudButton>
            <MudDivider />

            <div @ref="scrollSingleChatContainer" style="overflow-y: auto;" @onscroll="OnSingleChatScroll">
                @foreach (var chatItem in singleChatList)
                {
                    <MudButton Class="@($"textLeftButton {(selectedChatId == chatItem.ChatId ? "chatSelected" : "")}")"
                               OnClick="(() => ChatGroupClick(chatItem.ChatId))"
                               FullWidth>
                        <MudBadge Color="chatItem.Member1vs1Display.UserInformation.IsOnline ? Color.Success : Color.Error"
                                  Overlap="true"
                                  Bordered="true"
                                  Class="mr-3 float-start">
                            <MudAvatar>
                                <MudImage Src="@chatItem.Member1vs1Display.UserInformation.AvatarImage"></MudImage>
                            </MudAvatar>
                        </MudBadge>

                        <div class="float-end text-start">
                            <MudText Typo="Typo.subtitle1">@chatItem.Member1vs1Display.UserInformation.FullName</MudText>
                            <MudText Typo="Typo.subtitle2">@chatItem.LastChatTime.ToString("dd/MM/yyyy HH:mm:ss")</MudText>
                        </div>
                    </MudButton>
                }
            </div>
        </MudPaper>

        <MudPaper Class="pa-4 mt-2">
            <MudButton FullWidth Class="textLeftButton" Color="Color.Success">@_languageService["Spaces"]</MudButton>
            <MudDivider />

            <div @ref="scrollGroupChatContainer" style="overflow-y: auto;" @onscroll="OnGroupChatScroll">
                @foreach (var chatItem in groupChatList)
                {
                    <MudButton Class="@($"textLeftButton {(selectedChatId == chatItem.ChatId ? "chatSelected" : "")}")"
                               OnClick="(() => ChatGroupClick(chatItem.ChatId))"
                               FullWidth>
                        <MudAvatar Class="mr-3 float-start">
                            <MudImage Src="@chatItem.GroupAvatar"></MudImage>
                        </MudAvatar>
                        <div class="float-end text-start">
                            <MudText Typo="Typo.subtitle1">@chatItem.ChatName</MudText>
                            <MudText Typo="Typo.subtitle2">@chatItem.LastChatTime.ToString("dd/MM/yyyy HH:mm:ss")</MudText>
                        </div>
                    </MudButton>
                }
            </div>
        </MudPaper>
    </MudItem>

    <MudItem md="8" sm="12" xs="12">
        <MudTextField @bind-Value="messageSearchKeyWord"
                      Placeholder="@_languageService["Search"]"
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.Search"
                      Class="searchBoxStyle" />

        <div class="chat-container mt-2">
            <div class="message-list" @ref="scrollChatMessageContainer">

                @foreach (var message in messageList)
                {
                    if (message.CreatedId != userLogin.UserId)
                    {
                        <!-- Left Message -->
                        <div class="message-left">
                            <div class="avatar">
                                <img src="@message.CreateUser.AvatarImage" alt="Avatar">
                            </div>
                            <div class="message-container">
                                <div class="sender-name">@message.CreateUser.FullName</div>
                                <div class="message-content">
                                    @switch (@message.MessageType)
                                    {
                                        case TypeMessageConstant.Image:
                                            <img src="@message.Content" alt="Image Message" class="message-image" />
                                            break;
                                        case TypeMessageConstant.File:
                                            <div class="message-text">@message.Content</div>
                                            break;
                                        case TypeMessageConstant.Video:
                                            <div class="message-text">@message.Content</div>
                                            break;
                                        default:
                                            <div class="message-text">@message.Content</div>
                                            break;
                                    }
                                    <div class="message-time">@message.CreatedDate.ToString("dd/MM/yyyy HH:mm:ss tt", CultureInfo.InvariantCulture)</div>
                                </div>
                            </div>
                        </div>
                    }
                    else
                    {
                        <!-- Right Message -->
                        <div class="message-right">
                            <div class="message-content">
                                @switch (@message.MessageType)
                                {
                                    case TypeMessageConstant.Image:
                                        <img src="@message.Content" alt="Image Message" class="message-image" />
                                        break;
                                    case TypeMessageConstant.File:
                                        <div class="message-text">@message.Content</div>
                                        break;
                                    case TypeMessageConstant.Video:
                                        <div class="message-text">@message.Content</div>
                                        break;
                                    default:
                                        <div class="message-text">@message.Content</div>
                                        break;
                                }
                                <div class="message-time">@message.CreatedDate.ToString("dd/MM/yyyy HH:mm:ss tt", CultureInfo.InvariantCulture)</div>
                            </div>
                            <div class="avatar">
                                <img src="@message.CreateUser.AvatarImage" alt="Avatar">
                            </div>
                        </div>
                    }

                }

            </div>

            <div class="input-container">
                <MudTextField @bind-Value="messageInput"
                              Placeholder="@_languageService["TypeAMessage"]"
                              Variant="Variant.Outlined"
                              OnKeyUp="@SendMessageKeyUpAction"
                              Class="searchBoxStyle" />
                <MudIconButton Icon="@Icons.Material.Filled.Send" OnClick="(await => SendMessage())"></MudIconButton>
            </div>
        </div>

    </MudItem>


</MudGrid>

<LoadingComponent IsLoading="isLoading" />

@code {
    private bool isLoading = false;
    private UserDto userLogin = new();
    private string messageSearchKeyWord = string.Empty;
    private bool isOnsearch = false;
    private List<ChatDto> groupChatList = new();
    private List<ChatDto> singleChatList = new();
    private List<MessageDto> messageList = new();
    private int singleChatPageIndex = 1;
    private int groupChatPageIndex = 1;
    private int messagePageIndex = 1;
    private int chatPageSize = 7;
    private int messagePageSize = 20;
    private HubConnection hubConnection;
    private string messageInput = string.Empty;
    private long selectedChatId = 0;
    private int selectedMessageType = TypeMessageConstant.Message;

    private ElementReference scrollSingleChatContainer;
    private ElementReference scrollGroupChatContainer;
    private ElementReference scrollChatMessageContainer;

    private async Task SendMessageKeyUpAction(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendMessage();
            Console.WriteLine($"Message Input after Send: {messageInput}");
        }
    }

    private async Task SendMessage()
    {
        try
        {
            if (selectedChatId == 0 || string.IsNullOrEmpty(messageInput))
            {
                return;
            }
            var request = new SendMessageRequest()
                {
                    ChatId = selectedChatId,
                    Content = messageInput,
                    MessageType = selectedMessageType
                };
            var sendMessageResponse = await _chatService.SendMessageAsync(request);
            var messageDto = sendMessageResponse?.Data ?? new();
            if (messageDto == null || messageDto.MessageId == 0 || messageList.Any(item => item.MessageId == messageDto.MessageId))
            {
                return;
            }
            messageList.Add(messageDto);
            messageList = messageList.OrderByDescending(item => item.CreatedDate).ToList();
        }
        finally
        {
            messageInput = string.Empty;
            selectedMessageType = TypeMessageConstant.Message;

            Console.WriteLine("State is being changed.");
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnSingleChatScroll()
    {
        var scrollTop = await _jSRuntime.InvokeAsync<double>("blazorGetScrollTop", scrollSingleChatContainer);
        var scrollHeight = await _jSRuntime.InvokeAsync<double>("blazorGetScrollHeight", scrollSingleChatContainer);
        var clientHeight = await _jSRuntime.InvokeAsync<double>("blazorGetClientHeight", scrollSingleChatContainer);

        if (scrollTop + clientHeight >= scrollHeight - 50 && !isLoading)
        {
            await LoadSingleChatList();
        }
    }

    private async Task OnGroupChatScroll()
    {
        var scrollTop = await _jSRuntime.InvokeAsync<double>("blazorGetScrollTop", scrollGroupChatContainer);
        var scrollHeight = await _jSRuntime.InvokeAsync<double>("blazorGetScrollHeight", scrollGroupChatContainer);
        var clientHeight = await _jSRuntime.InvokeAsync<double>("blazorGetClientHeight", scrollGroupChatContainer);

        if (scrollTop + clientHeight >= scrollHeight - 50 && !isLoading)
        {
            await LoadGroupChatList();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        var dimension = await _jSRuntime.InvokeAsync<WindowDimensions>("getWindowSize");
        var heightContainer = dimension.Height - dimension.FormHeight - dimension.ToolbarHeight;
        var heightGrid = (heightContainer - 275) / 2;
        var heightMessageChat = heightContainer - 205;
        await _jSRuntime.InvokeVoidAsync("blazorSetElementHeight", scrollSingleChatContainer, heightGrid);
        await _jSRuntime.InvokeVoidAsync("blazorSetElementHeight", scrollGroupChatContainer, heightGrid);
        await _jSRuntime.InvokeVoidAsync("blazorSetElementHeight", scrollChatMessageContainer, heightMessageChat);
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            isLoading = true;
            StateHasChanged();

            await _languageService.LoadLanguage();
            userLogin = await _localStorage.GetItemAsync<UserDto>(KeyConstant.UserLogin) ?? new();
            singleChatPageIndex = 1;
            groupChatPageIndex = 1;
            await LoadSingleChatList();
            await LoadGroupChatList();
            await RegisterSocketClient();
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task OpenAddNewChatDialog()
    {
        var options = new DialogOptions { CloseOnEscapeKey = true, CloseButton = true };
        var dialog = await _dialogService.ShowAsync<AddNewChatDialog>(_languageService["NewChat"], options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            var chatId = (long)(result.Data);
            if (chatId == 0)
            {
                return;
            }
            singleChatPageIndex = 1;
            groupChatPageIndex = 1;
            await LoadSingleChatList();
            await LoadGroupChatList();
        }
    }

    private async Task LoadGroupChatList()
    {
        if (isOnsearch)
        {
            return;
        }
        try
        {
            isOnsearch = true;
            GetListChatGroupByMemberRequest request = new();
            request.PageIndex = groupChatPageIndex;
            request.PageSize = chatPageSize;
            request.IsGroupChat = true;
            request.MemberId = userLogin.UserId;
            var response = await _chatService.GetListChatGroupByMemberAsync(request);
            var resultData = response?.Data ?? new();
            if (!resultData.Any())
            {
                isOnsearch = false;
                return;
            }
            var resultChatIds = resultData.Select(dt => dt.ChatId).ToHashSet();

            groupChatList = groupChatList.Where(item => !resultChatIds.Contains(item.ChatId))
                                         .Concat(resultData)
                                         .OrderByDescending(item => item.LastChatTime)
                                         .ToList();
            groupChatPageIndex++;
            StateHasChanged();
        }
        finally
        {
            isOnsearch = false;
        }
    }

    private async Task LoadSingleChatList()
    {
        if (isOnsearch)
        {
            return;
        }
        try
        {
            isOnsearch = true;
            GetListChatGroupByMemberRequest request = new();
            request.PageIndex = singleChatPageIndex;
            request.PageSize = chatPageSize;
            request.IsGroupChat = false;
            request.MemberId = userLogin.UserId;
            var response = await _chatService.GetListChatGroupByMemberAsync(request);
            var resultData = response?.Data ?? new();
            if (!resultData.Any())
            {
                isOnsearch = false;
                return;
            }
            var resultChatIds = resultData.Select(dt => dt.ChatId).ToHashSet();

            singleChatList = singleChatList.Where(item => !resultChatIds.Contains(item.ChatId))
                                           .Concat(resultData)
                                           .OrderByDescending(item => item.LastChatTime)
                                           .ToList();
            singleChatPageIndex++;
            foreach (var item in singleChatList)
            {
                item.Set1vs1Member(userLogin.UserId);
            }
            StateHasChanged();
        }
        finally
        {
            isOnsearch = false;
        }
    }

    private async Task ChatGroupClick(long chatId)
    {
        selectedChatId = chatId;
        messagePageIndex = 1;
        await LoadChatMessage();
    }

    private async Task LoadChatMessage()
    {
        GetMessageListRequest request = new();
        request.PageIndex = messagePageIndex;
        request.PageSize = messagePageSize;
        request.ChatId = selectedChatId;
        request.KeyWord = messageSearchKeyWord;
        var response = await _chatService.GetMessageListAsync(request);
        messageList = response?.Data ?? new();
    }

    private async Task RegisterSocketClient()
    {
        string hubUrl = _configuration["SignalR:HubUrl"] ?? string.Empty;

        hubConnection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .Build();

        hubConnection.On<string>(RealtimeConstant.UserStatus, async (message) =>
        {
            var userSocketList = JsonSerializer.Deserialize<List<UserDto>>(message);
            if (userSocketList == null || !userSocketList.Any())
            {
                return;
            }
            var userDictionary = userSocketList.ToDictionary(u => u.UserId);
            var chatsToUpdate = singleChatList
                .Where(chat => userDictionary.ContainsKey(chat.Member1vs1Display.UserInformation.UserId))
                .ToList();

            if (!chatsToUpdate.Any())
            {
                return;
            }
            foreach (var chat in chatsToUpdate)
            {
                var updateUser = userDictionary[chat.Member1vs1Display.UserInformation.UserId];
                chat.ChangeUserMember1vs1Display(updateUser);
            }
            await InvokeAsync(StateHasChanged);
        });

        hubConnection.On<string>(RealtimeConstant.ReceiveMessage, async (message) =>
        {
            var messageSocket = JsonSerializer.Deserialize<MessageDto>(message);
            if (messageSocket == null || messageSocket.MessageId == 0 || messageList.Any(item => item.MessageId == messageSocket.MessageId))
            {
                return;
            }
            messageList.Add(messageSocket);
            messageList = messageList.OrderByDescending(item => item.CreatedDate).ToList();
            await InvokeAsync(StateHasChanged);
        });

        try
        {
            await hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            throw;
        }
    }
}